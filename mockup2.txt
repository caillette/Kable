
Playbook2 {

    // 1. Naked action.
    
    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" )


    // 2. Use modifiers.
    //    Every Action may declare its own modifiers so we propagate the type
    //    using the '+' at the end. 
    //    There should be some ThreadLocal-based check to warn when creating
    //    modifiers without the '+'.

    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" ) +
      modifiers( connection = Connection.LOCAL, ignoreErrors = true, runOnce = true )      


    // 3. Deferred capture: 'expand' value has type Deferred< ActionResult >.
    //    Capture causes asynchronous execution. 
    //    A Deferred object is some kind of Java Future.

    val expand = capture( deferred = true ) on
    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" )

    val expand = capture( deferred = true, transform = { it.stdout } ) on
    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" )


    // 4. Capture with transformation: 'expand' value has type Deferred< String >, 
    //    because that's what the closure transforms the result into, when available.

    val expand = capture( deferred = true, transform = { it.stdout } ) on
    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" ) +
      modifiers( connection = Connection.LOCAL, ignoreErrors = true, runOnce = true )


    // 5. All at once.

    val expand = applying { it.stdout } capture
    - Expand( archiveFilename = "/Downloads/jre.tar", destination = "/var/lib" ) +
      modifiers( connection = Connection.LOCAL, ignoreErrors = true, runOnce = true )


}